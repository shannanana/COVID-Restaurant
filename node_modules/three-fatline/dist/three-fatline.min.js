// Version 0.4.1 three-fatline - https://github.com/vasturiano/three-fatline
!function(t,e){"object"==typeof exports&&"undefined"!=typeof module?e(exports,require("three")):"function"==typeof define&&define.amd?define(["exports","three"],e):e((t="undefined"!=typeof globalThis?globalThis:t||self).THREE=t.THREE||{},t.THREE)}(this,(function(t,e){"use strict";const n=window.THREE?window.THREE:{Box3:e.Box3,BufferGeometry:e.BufferGeometry,Float32BufferAttribute:e.Float32BufferAttribute,InstancedBufferGeometry:e.InstancedBufferGeometry,InstancedInterleavedBuffer:e.InstancedInterleavedBuffer,InterleavedBufferAttribute:e.InterleavedBufferAttribute,Sphere:e.Sphere,Vector3:e.Vector3,WireframeGeometry:e.WireframeGeometry};var i,r,a=(new n.BufferGeometry).setAttribute?"setAttribute":"addAttribute",o=function(){n.InstancedBufferGeometry.call(this),this.type="LineSegmentsGeometry";this.setIndex([0,2,1,2,3,1,2,4,3,4,5,3,4,6,5,6,7,5]),this[a]("position",new n.Float32BufferAttribute([-1,2,0,1,2,0,-1,1,0,1,1,0,-1,0,0,1,0,0,-1,-1,0,1,-1,0],3)),this[a]("uv",new n.Float32BufferAttribute([-1,2,1,2,-1,1,1,1,-1,-1,1,-1,-1,-2,1,-2],2))};o.prototype=Object.assign(Object.create(n.InstancedBufferGeometry.prototype),{constructor:o,isLineSegmentsGeometry:!0,applyMatrix:function(t){return console.warn("THREE.LineSegmentsGeometry: applyMatrix() has been renamed to applyMatrix4()."),this.applyMatrix4(t)},applyMatrix4:function(t){var e=this.attributes.instanceStart,n=this.attributes.instanceEnd;return void 0!==e&&(t.applyToBufferAttribute(e),t.applyToBufferAttribute(n),e.data.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this},setPositions:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var i=new n.InstancedInterleavedBuffer(e,6,1);return this[a]("instanceStart",new n.InterleavedBufferAttribute(i,3,0)),this[a]("instanceEnd",new n.InterleavedBufferAttribute(i,3,3)),this.computeBoundingBox(),this.computeBoundingSphere(),this},setColors:function(t){var e;t instanceof Float32Array?e=t:Array.isArray(t)&&(e=new Float32Array(t));var i=new n.InstancedInterleavedBuffer(e,6,1);return this[a]("instanceColorStart",new n.InterleavedBufferAttribute(i,3,0)),this[a]("instanceColorEnd",new n.InterleavedBufferAttribute(i,3,3)),this},fromWireframeGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromEdgesGeometry:function(t){return this.setPositions(t.attributes.position.array),this},fromMesh:function(t){return this.fromWireframeGeometry(new n.WireframeGeometry(t.geometry)),this},fromLineSegements:function(t){var e=t.geometry;return e.isGeometry?this.setPositions(e.vertices):e.isBufferGeometry&&this.setPositions(e.position.array),this},computeBoundingBox:(r=new n.Box3,function(){null===this.boundingBox&&(this.boundingBox=new n.Box3);var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;void 0!==t&&void 0!==e&&(this.boundingBox.setFromBufferAttribute(t),r.setFromBufferAttribute(e),this.boundingBox.union(r))}),computeBoundingSphere:(i=new n.Vector3,function(){null===this.boundingSphere&&(this.boundingSphere=new n.Sphere),null===this.boundingBox&&this.computeBoundingBox();var t=this.attributes.instanceStart,e=this.attributes.instanceEnd;if(void 0!==t&&void 0!==e){var r=this.boundingSphere.center;this.boundingBox.getCenter(r);for(var a=0,o=0,s=t.count;o<s;o++)i.fromBufferAttribute(t,o),a=Math.max(a,r.distanceToSquared(i)),i.fromBufferAttribute(e,o),a=Math.max(a,r.distanceToSquared(i));this.boundingSphere.radius=Math.sqrt(a),isNaN(this.boundingSphere.radius)&&console.error("THREE.LineSegmentsGeometry.computeBoundingSphere(): Computed radius is NaN. The instanced position data is likely to have NaN values.",this)}}),toJSON:function(){},clone:function(){},copy:function(){return this}});const s=window.THREE?window.THREE:{ShaderLib:e.ShaderLib,ShaderMaterial:e.ShaderMaterial,UniformsLib:e.UniformsLib,UniformsUtils:e.UniformsUtils,Vector2:e.Vector2};s.UniformsLib.line={linewidth:{value:1},resolution:{value:new e.Vector2(1,1)},dashScale:{value:1},dashSize:{value:1},dashOffset:{value:0},gapSize:{value:1},opacity:{value:1}},s.ShaderLib.line={uniforms:s.UniformsUtils.merge([s.UniformsLib.common,s.UniformsLib.fog,s.UniformsLib.line]),vertexShader:"\n\t\t#include <common>\n\t\t#include <color_pars_vertex>\n\t\t#include <fog_pars_vertex>\n\t\t#include <logdepthbuf_pars_vertex>\n\t\t#include <clipping_planes_pars_vertex>\n\n\t\tuniform float linewidth;\n\t\tuniform vec2 resolution;\n\n\t\tattribute vec3 instanceStart;\n\t\tattribute vec3 instanceEnd;\n\n\t\tattribute vec3 instanceColorStart;\n\t\tattribute vec3 instanceColorEnd;\n\n\t\tvarying vec2 vUv;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashScale;\n\t\t\tattribute float instanceDistanceStart;\n\t\t\tattribute float instanceDistanceEnd;\n\t\t\tvarying float vLineDistance;\n\n\t\t#endif\n\n\t\tvoid trimSegment( const in vec4 start, inout vec4 end ) {\n\n\t\t\t// trim end segment so it terminates between the camera plane and the near plane\n\n\t\t\t// conservative estimate of the near plane\n\t\t\tfloat a = projectionMatrix[ 2 ][ 2 ]; // 3nd entry in 3th column\n\t\t\tfloat b = projectionMatrix[ 3 ][ 2 ]; // 3nd entry in 4th column\n\t\t\tfloat nearEstimate = - 0.5 * b / a;\n\n\t\t\tfloat alpha = ( nearEstimate - start.z ) / ( end.z - start.z );\n\n\t\t\tend.xyz = mix( start.xyz, end.xyz, alpha );\n\n\t\t}\n\n\t\tvoid main() {\n\n\t\t\t#ifdef USE_COLOR\n\n\t\t\t\tvColor.xyz = ( position.y < 0.5 ) ? instanceColorStart : instanceColorEnd;\n\n\t\t\t#endif\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tvLineDistance = ( position.y < 0.5 ) ? dashScale * instanceDistanceStart : dashScale * instanceDistanceEnd;\n\n\t\t\t#endif\n\n\t\t\tfloat aspect = resolution.x / resolution.y;\n\n\t\t\tvUv = uv;\n\n\t\t\t// camera space\n\t\t\tvec4 start = modelViewMatrix * vec4( instanceStart, 1.0 );\n\t\t\tvec4 end = modelViewMatrix * vec4( instanceEnd, 1.0 );\n\n\t\t\t// special case for perspective projection, and segments that terminate either in, or behind, the camera plane\n\t\t\t// clearly the gpu firmware has a way of addressing this issue when projecting into ndc space\n\t\t\t// but we need to perform ndc-space calculations in the shader, so we must address this issue directly\n\t\t\t// perhaps there is a more elegant solution -- WestLangley\n\n\t\t\tbool perspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 ); // 4th entry in the 3rd column\n\n\t\t\tif ( perspective ) {\n\n\t\t\t\tif ( start.z < 0.0 && end.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( start, end );\n\n\t\t\t\t} else if ( end.z < 0.0 && start.z >= 0.0 ) {\n\n\t\t\t\t\ttrimSegment( end, start );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t// clip space\n\t\t\tvec4 clipStart = projectionMatrix * start;\n\t\t\tvec4 clipEnd = projectionMatrix * end;\n\n\t\t\t// ndc space\n\t\t\tvec2 ndcStart = clipStart.xy / clipStart.w;\n\t\t\tvec2 ndcEnd = clipEnd.xy / clipEnd.w;\n\n\t\t\t// direction\n\t\t\tvec2 dir = ndcEnd - ndcStart;\n\n\t\t\t// account for clip-space aspect ratio\n\t\t\tdir.x *= aspect;\n\t\t\tdir = normalize( dir );\n\n\t\t\t// perpendicular to dir\n\t\t\tvec2 offset = vec2( dir.y, - dir.x );\n\n\t\t\t// undo aspect ratio adjustment\n\t\t\tdir.x /= aspect;\n\t\t\toffset.x /= aspect;\n\n\t\t\t// sign flip\n\t\t\tif ( position.x < 0.0 ) offset *= - 1.0;\n\n\t\t\t// endcaps\n\t\t\tif ( position.y < 0.0 ) {\n\n\t\t\t\toffset += - dir;\n\n\t\t\t} else if ( position.y > 1.0 ) {\n\n\t\t\t\toffset += dir;\n\n\t\t\t}\n\n\t\t\t// adjust for linewidth\n\t\t\toffset *= linewidth;\n\n\t\t\t// adjust for clip-space to screen-space conversion // maybe resolution should be based on viewport ...\n\t\t\toffset /= resolution.y;\n\n\t\t\t// select end\n\t\t\tvec4 clip = ( position.y < 0.5 ) ? clipStart : clipEnd;\n\n\t\t\t// back to clip space\n\t\t\toffset *= clip.w;\n\n\t\t\tclip.xy += offset;\n\n\t\t\tgl_Position = clip;\n\n\t\t\tvec4 mvPosition = ( position.y < 0.5 ) ? start : end; // this is an approximation\n\n\t\t\t#include <logdepthbuf_vertex>\n\t\t\t#include <clipping_planes_vertex>\n\t\t\t#include <fog_vertex>\n\n\t\t}\n\t\t",fragmentShader:"\n\t\tuniform vec3 diffuse;\n\t\tuniform float opacity;\n\n\t\t#ifdef USE_DASH\n\n\t\t\tuniform float dashSize;\n\t\t\tuniform float dashOffset;\n\t\t\tuniform float gapSize;\n\n\t\t#endif\n\n\t\tvarying float vLineDistance;\n\n\t\t#include <common>\n\t\t#include <color_pars_fragment>\n\t\t#include <fog_pars_fragment>\n\t\t#include <logdepthbuf_pars_fragment>\n\t\t#include <clipping_planes_pars_fragment>\n\n\t\tvarying vec2 vUv;\n\n\t\tvoid main() {\n\n\t\t\t#include <clipping_planes_fragment>\n\n\t\t\t#ifdef USE_DASH\n\n\t\t\t\tif ( vUv.y < - 1.0 || vUv.y > 1.0 ) discard; // discard endcaps\n\n\t\t\t\tif ( mod( vLineDistance + dashOffset, dashSize + gapSize ) > dashSize ) discard; // todo - FIX\n\n\t\t\t#endif\n\n\t\t\tif ( abs( vUv.y ) > 1.0 ) {\n\n\t\t\t\tfloat a = vUv.x;\n\t\t\t\tfloat b = ( vUv.y > 0.0 ) ? vUv.y - 1.0 : vUv.y + 1.0;\n\t\t\t\tfloat len2 = a * a + b * b;\n\n\t\t\t\tif ( len2 > 1.0 ) discard;\n\n\t\t\t}\n\n\t\t\tvec4 diffuseColor = vec4( diffuse, opacity );\n\n\t\t\t#include <logdepthbuf_fragment>\n\t\t\t#include <color_fragment>\n\n\t\t\tgl_FragColor = vec4( diffuseColor.rgb, diffuseColor.a );\n\n\t\t\t#include <tonemapping_fragment>\n\t\t\t#include <encodings_fragment>\n\t\t\t#include <fog_fragment>\n\t\t\t#include <premultiplied_alpha_fragment>\n\n\t\t}\n\t\t"};var c=function(t){s.ShaderMaterial.call(this,{type:"LineMaterial",uniforms:s.UniformsUtils.clone(s.ShaderLib.line.uniforms),vertexShader:s.ShaderLib.line.vertexShader,fragmentShader:s.ShaderLib.line.fragmentShader,clipping:!0}),this.dashed=!1,Object.defineProperties(this,{color:{enumerable:!0,get:function(){return this.uniforms.diffuse.value},set:function(t){this.uniforms.diffuse.value=t}},linewidth:{enumerable:!0,get:function(){return this.uniforms.linewidth.value},set:function(t){this.uniforms.linewidth.value=t}},dashScale:{enumerable:!0,get:function(){return this.uniforms.dashScale.value},set:function(t){this.uniforms.dashScale.value=t}},dashSize:{enumerable:!0,get:function(){return this.uniforms.dashSize.value},set:function(t){this.uniforms.dashSize.value=t}},dashOffset:{enumerable:!0,get:function(){return this.uniforms.dashOffset.value},set:function(t){this.uniforms.dashOffset.value=t}},gapSize:{enumerable:!0,get:function(){return this.uniforms.gapSize.value},set:function(t){this.uniforms.gapSize.value=t}},opacity:{enumerable:!0,get:function(){return this.uniforms.opacity.value},set:function(t){this.uniforms.opacity.value=t}},resolution:{enumerable:!0,get:function(){return this.uniforms.resolution.value},set:function(t){this.uniforms.resolution.value.copy(t)}}}),this.setValues(t)};(c.prototype=Object.create(s.ShaderMaterial.prototype)).constructor=c,c.prototype.isLineMaterial=!0,c.prototype.copy=function(t){return s.ShaderMaterial.prototype.copy.call(this,t),this.color.copy(t.color),this.linewidth=t.linewidth,this.resolution=t.resolution,this};const u=window.THREE?window.THREE:{BufferGeometry:e.BufferGeometry,InstancedInterleavedBuffer:e.InstancedInterleavedBuffer,InterleavedBufferAttribute:e.InterleavedBufferAttribute,Line3:e.Line3,MathUtils:e.MathUtils,Matrix4:e.Matrix4,Mesh:e.Mesh,Vector3:e.Vector3,Vector4:e.Vector4};var f,l,d=(new u.BufferGeometry).setAttribute?"setAttribute":"addAttribute",p=function(t,e){void 0===t&&(t=new o),void 0===e&&(e=new c({color:16777215*Math.random()})),u.Mesh.call(this,t,e),this.type="LineSegments2"};p.prototype=Object.assign(Object.create(u.Mesh.prototype),{constructor:p,isLineSegments2:!0,computeLineDistances:(f=new u.Vector3,l=new u.Vector3,function(){for(var t=this.geometry,e=t.attributes.instanceStart,n=t.attributes.instanceEnd,i=new Float32Array(2*e.data.count),r=0,a=0,o=e.data.count;r<o;r++,a+=2)f.fromBufferAttribute(e,r),l.fromBufferAttribute(n,r),i[a]=0===a?0:i[a-1],i[a+1]=i[a]+f.distanceTo(l);var s=new u.InstancedInterleavedBuffer(i,2,1);return t[d]("instanceDistanceStart",new u.InterleavedBufferAttribute(s,1,0)),t[d]("instanceDistanceEnd",new u.InterleavedBufferAttribute(s,1,1)),this}),raycast:function(){var t=new u.Vector4,e=new u.Vector4,n=new u.Vector4,i=new u.Vector3,r=new u.Matrix4,a=new u.Line3,o=new u.Vector3;return function(s,c){null===s.camera&&console.error('LineSegments2: "Raycaster.camera" needs to be set in order to raycast against LineSegments2.');var f=void 0!==s.params.Line2&&s.params.Line2.threshold||0,l=s.ray,d=s.camera,p=d.projectionMatrix,h=this.geometry,m=this.material,v=m.resolution,y=m.linewidth+f,b=h.attributes.instanceStart,g=h.attributes.instanceEnd;l.at(1,n),n.w=1,n.applyMatrix4(d.matrixWorldInverse),n.applyMatrix4(p),n.multiplyScalar(1/n.w),n.x*=v.x/2,n.y*=v.y/2,n.z=0,i.copy(n);var S=this.matrixWorld;r.multiplyMatrices(d.matrixWorldInverse,S);for(var x=0,w=b.count;x<w;x++){t.fromBufferAttribute(b,x),e.fromBufferAttribute(g,x),t.w=1,e.w=1,t.applyMatrix4(r),e.applyMatrix4(r),t.applyMatrix4(p),e.applyMatrix4(p),t.multiplyScalar(1/t.w),e.multiplyScalar(1/e.w);var B=t.z<-1&&e.z<-1,E=t.z>1&&e.z>1;if(!B&&!E){t.x*=v.x/2,t.y*=v.y/2,e.x*=v.x/2,e.y*=v.y/2,a.start.copy(t),a.start.z=0,a.end.copy(e),a.end.z=0;var A=a.closestPointToPointParameter(i,!0);a.at(A,o);var M=u.MathUtils.lerp(t.z,e.z,A),L=M>=-1&&M<=1,_=i.distanceTo(o)<.5*y;if(L&&_){a.start.fromBufferAttribute(b,x),a.end.fromBufferAttribute(g,x),a.start.applyMatrix4(S),a.end.applyMatrix4(S);var z=new u.Vector3,I=new u.Vector3;l.distanceSqToSegment(a.start,a.end,I,z),c.push({point:I,pointOnLine:z,distance:l.origin.distanceTo(I),object:this,face:null,faceIndex:x,uv:null,uv2:null})}}}}}()});var h=function(){o.call(this),this.type="LineGeometry"};h.prototype=Object.assign(Object.create(o.prototype),{constructor:h,isLineGeometry:!0,setPositions:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return o.prototype.setPositions.call(this,n),this},setColors:function(t){for(var e=t.length-3,n=new Float32Array(2*e),i=0;i<e;i+=3)n[2*i]=t[i],n[2*i+1]=t[i+1],n[2*i+2]=t[i+2],n[2*i+3]=t[i+3],n[2*i+4]=t[i+4],n[2*i+5]=t[i+5];return o.prototype.setColors.call(this,n),this},fromLine:function(t){var e=t.geometry;return e.isGeometry?this.setPositions(e.vertices):e.isBufferGeometry&&this.setPositions(e.position.array),this},copy:function(){return this}});var m=function(t,e){p.call(this),this.type="Line2",this.geometry=void 0!==t?t:new h,this.material=void 0!==e?e:new c({color:16777215*Math.random()})};m.prototype=Object.assign(Object.create(p.prototype),{constructor:m,isLine2:!0,copy:function(){return this}}),t.Line2=m,t.LineGeometry=h,t.LineMaterial=c,t.LineSegments2=p,t.LineSegmentsGeometry=o,Object.defineProperty(t,"__esModule",{value:!0})}));
